#### 作用域

当在某个函数作用域里使用了未定义的变量，则会向上级寻找这个变量直到找到

```js
function print(fn){
    const a = 200;
    fn();
}

const a = 100;
function fn(){
    console.log(a);
}
print(fn); //100 
```

#### this

##### 在全局环境下

this指向全局对象
- 游览器 window
- node globalThis

##### function中

- 严格模式下 未设置this则为undefined
- 非严格模式下 未设置this则为全局对象
**即便function嵌套在其他对象/function中也是如此**

##### 事件处理函数中
在没有嵌套在其他函数中时指向引发事件的元素，

##### bind()
bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

##### call()

call() 允许为不同的对象分配和调用属于一个对象的函数/方法。

call() 提供新的 this 值给当前调用的函数/方法。你可以使用 call 来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。

```js
function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  Product.call(this, name, price);
  this.category = 'food';
}

console.log(new Food('cheese', 5).name);
// expected output: "cheese"
```

使用调用者提供的 this 值和参数调用该函数的返回值。若该方法没有返回值，则返回 undefined

##### apply()

apply() 方法调用一个具有给定this值的函数，以及以一个数组（或类数组对象）的形式提供的参
call()方法的作用和 apply() 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组

##### 箭头函数

箭头函数没有自己的this，arguments，super或new.target。在bind()、apply()、call()中使用箭头函数会使绑定失效。

```js
const arrow ={
    wait(){
        setTimeout(function(){
            console.log(this);//window
        })
    }
}
const arrow ={
    wait(){
        setTimeout(()=>{
            console.log(this);//当前对象 arrow
        })
    }
}
```


#### 手写bind()

```js
Function.prototype.bind1 = function(){
    const args = Array.prototype.slice.call(arguments);
    const t = args.shift();
    const self = this; //this为fn.bind的fn

    return function(){
        return self.apply(t,args);
    }
}

```